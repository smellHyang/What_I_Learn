# 서비스 디스커버리

## 2. 목적

- 해당 환경에서 실행하는 서비스 인스턴스 개수를 수평확장하거나 축소가능
- 애플리케이션 회복성 향상
    - 장애 시 서비스 디스커버리 엔진에서 해당 인스턴스 제거

## 3. 로드밸런스, DNS 가 적합하지 않은이유

- 로드밸런서 자체도 다운되면 이에 의존하는 모든 애플리케이션도 다운될수 있다.(**SPOF**)
- **수평확장의 제약성** : 로드밸런서 클러스터에 서비스를 모아 연결하므로 부하분산 인프라를 여러 서버에 수평적으로 확장할수 있는 능력이 제한
- **정적관리 :** 로드밸런서에 서비스를 신속히 등록 및 취소하기 어렵다**.**
- 복잡성 : Client에게 요청할때 물리적인 서비스 정보가 필요하다. 이는 수동으로 정의하고 배포해야 하므로 서비스 인프라에 복잡성을 준다.

## 4. 특징

- 고가용성 : 한노드가 사용할수 없게되면 다른노드가 이어받아 운영
- Peer-to-Peer : 클러스터의 각 ㄴ노드는 서비스 인스턴스의 상태를 공유
- 부하분산 : 동적으로 로드밸런싱하여 모든서비스레 분배
- 회복성 : client는 서비스 정보를 캐싱하고 장애 시 캐시정보를 기반으로 동작
- 장애내성 : 서비스 인스턴스 비정상은 탐지하고 삭제

## 동작

                 **서비스 디스커버리 계층                서비스 인스턴스(서비스A)**

**Client →[   서비스 디스커버리 노드 1, 2, 3      ] → [   서비스 인스턴스 1,2,3  ]**

- 서비스 디스커버리 에이전트를 이용해 논리적이름으로 서비스 위치 검색
- 서비스가 온라인상태가 되면 자기IP주소를 에이전트에 등록
- 노드는 인스턴스 상태정보를 서로 공유
- 서비스는 에이전트에 상태정보를 보내고 종료 시 인스턴스 IP주소를 제거

⇒ 이는 Client가 서비스를 찾고 호출하기 위해 서비스 디스커버리 엔진에 전적으로 의존

따라서 서비스 client 로컬 캐싱을 사용한다.
