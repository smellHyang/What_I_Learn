# 데이터베이스 데드락

1. 데이터베이스 데드락?
    - 여러개의 트랜잭션들이 실행하지 못하고 서로 무한정 기다리는 상태
    - 트랜잭션1이 테이블1을 업데이트 한뒤 테이블2를 업데이트 하려고 할때 트랜잭션2가 이미 테이블2 업데이트 작업을 진행 중인 경우 이 작업이 완료될때까지 대기 후 처리한다. 트랜잭션들이 서로 완료 될때 까지 기다리고 결과적으로 무한 대기 상황이 되면 데드락이 걸렸다고 표현한다.
    
  ![image](https://user-images.githubusercontent.com/73684562/166749514-74080bfa-d19b-4160-9295-eb2be97c1558.png)
    
    1. DB데드락의 종류
        - 순환 교착(Cycle Deadlock)
            - 데드락의 보통 예시
            - 두 트랜잭션이 필요한 리소스를 얻기 위해 서로 lock이 풀리기를 기다리는 상태
            - update ↔ update
        - 변환 교착(Conversion Deadlock)
            - 같은 대상에 대해 둘 이상의 세션이 동시에 잠금을 변경하려고 할때 발생
            - select ↔ update
            
    1. 해결방법 
        - 트랜잭션 진행방향을 같은 방향으로 처리 (테이블A 업데이트 후 테이블B 업데이트)
        - 트랜잭션 처리속도를 최소화
        - SET LOCK_TIMEOUT: 잠금해제 시간 설정
            - 데드락이 발생했을 때 잠금시간을 해제 해주면 무기한 대기하지 않고 다음작업을 진행할 수 있다.
            
            ```
            set lock_timeout 3000
            ```
            
    
    +) Lock 의 종류 
    
    - Shared Lock(Read Lock)
        - 데이터를 read할때 사용
        - 데이터에 lock을 걸었지만 다른세션에서 읽을 수 있다. 단 변경할 수는 없다
        - 공유 lock끼리는 동시 접근 가능(배타 lock은 안댐)
    - Exclusive Lock(Write Lock) ?
        - 데이터 변경 시 사용
        - 해당 락이 해제되기 전까지는 다른 공유락,배타적락을 사용 할 수 없다.
        - 읽기, 쓰기 모두 불가능
    
    +) Blocking??
    
    - Lock 간의 경합이 발생하여 특정 트랜잭션이 작업을 진행하지 못하고 멈춰선 상태
    - 공유락 끼리는 블로킹이 발생하지 않지만 배타락은 블로킹을 발생시킨다.
    - 해결방법은 이전의 트랜잭션이 완전히 commit 또는 rollback이 되어야 한다.
