# Garbage Collector
1. Garbage Collector란?
    - 시스템에서 더이상 사용하지 않는 동적 할당된 메모리블럭을 찾아 자동으로 다시 사용하능한 자원으로 회수 하는 것

1. 목적
    - 프로그램을 실행 할 때 os에 메모리를 요청하게 된다. 이때 메모리를 어디에 저장할 지에 대한 주소를 offset주소라고 부른다.
    - 할당된 메모리 들은 필연적으로 ‘가비지’가 발생하게 된다. 기존에 가리키고 있던 메모리를 새롭게 선언되거나 형변환이 되면서 다른곳을 가리키게 되면서 주소를 잃어버리거나 다시 찾지 못하여 정리되지 않은 메모리가 생길 수 밖에 없다.
    - Garbage collector는 이 정리되지 않은 메모리를 다른 용도로 사용할 수 있도록 메모리 해제를 시킨다.
    - Java에서는 JVM이 메모리를 부여받고 프로그램을 실행하다가 메모리가 부족해질 때 추가적으로 메모리를 요청한다. 이때 garbage collector가 실행된다.
    
2. Mark and Sweep 
    - GC 를 실행하면 JVM이 애플리케이션 실행을 멈춘다.  즉, GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춘다. (Stop-the-world)
    - GC가 닿을 수 있는 모든 변수나 객체들을 스캔하면서 사용되고 있는 메모리를 식별하는데 이를 Mark라고하고 이과정에서 실행을 멈춘다.
    - Mark되어이 있지 않은 객체들을 heap에서 제거하는 과정이 Sweep이다.

1. JVM의 힙영역
    
   ![image](https://user-images.githubusercontent.com/73684562/165229496-c4dea32d-d08c-4b7a-bad6-c8c06914c73d.png)

   
    - 크게 class영역, 자바stack, heap, nagative method stack 이렇게 4개로 나뉜다.  GC는 여기서 heap메모리를 다룬다.
    - Heap영역에서 Young, Old, Perm 이렇게 3가지 영역으로 나뉜다. Young영역에서 발생한 GC를 Minor GC, 나머지 두 영역에서 발생한 GC를 Major GC라고한다.
    - Young 영역
        - 새롭게 생성한 객체의 위치
        - 대부분의 객체가 금방 닿을 수 없는 상태가 되기 때문에 많은 객체가 이 영역에서 생성되어 사라진다.
    - Old 영역
        - Young영역에서 남은 객체가 여기로 복사된다.
        - 대부분 young 영역보다는 크게 할당되고, GC가 비교적 적게 발생
    - Perm 영역
        - 자바8부터 없어짐.

1. 동작원리
    - 메모리에 새로운 객체가 생성되면 Eden 영역에 객체가 지정된다. 이 영역에 데이터가 어느정도 쌓이면 객체가 다른곳으로 옮겨지거나 삭제된다. 이떄 옮겨지는 위치가 Survivor Space이다.
    - Survivor Space는 최소 1번 GC이후 살아남은 객체가 존재한다. 보통 2개의 영역이 있다. 우선순위는 없고 비어있는 곳에 지정되므로 둘 중 한개는 반드시 비어있어야한다. 여기서 객체가 살아남은 횟수를 파악한다.
    - 그러다가 더 큰 객체가 생성되거나 더이상 young영역에 공간이 없으면 객체들은 Old영역으로 이동하게 된다. old 영역에서는 young의 객체를 참조 할 수 있는 카드 테이블에(card table)에 기록해놓고 가비지 여부를 판단한다.
    - 객체 이동순서 : Eden → Survivor → Old

1. 단점
    - 런타임 때 작업하는 이상 성능하락을 피할 수 없다.
    - 더이상 접근이 불가능한 객체만 회수 하기 때문에 메모리 누수를 피할 순없다.
    - young영역보다 old영역의 메모리가 더 커서 old에서 gc발생시 멈추는 시간이 오래걸림으로 주의해야한다.
    

+) Bump the pointer / TLABs(TheadLocal Allocation Buffers)

- Bump the pointer
    - Eden 영역에 객체를 빠르게 할당하기 위함
    - Eden 영역에 마지막으로 할당된 객체의 주소를 캐싱해두는것
    - 따라서 새로운 객체가 할당 될떄 메모리를 탐색할 필요 없이 마지막 주소의 다음주소를 사용하게 함으로써 속도를 높인다.
    - 새로운 객체를 할당 할 때 객체의 크기가 적합한지만 판별하면 되므로 빠르게 메모리 할당 가능
- TLBs
    - 싱글쓰레드에선 문제가 없지만 멀티쓰레드에서는 객체를 eden 영역에 할당 할 떄 lock을 걸어 동기화를 해줘야한다.
    - 각각의 쓰레드마다 eden영역에 객체를 할당하기 위한 주소를 부여함으로써 동기화 작업 없이 빠르게 메모리를 할당
    - 각 쓰레드는 자신이 갖는 주소에만 객체를 할당함으로써 동기화 없이 Bump the pointer를 통해 빠르게 객체를 할당받는다.
